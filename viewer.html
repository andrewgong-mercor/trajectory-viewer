<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trajectory Code Viewer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
    <!-- WebLLM for in-browser AI -->
    <script type="module">
        import * as webllm from "https://esm.run/@mlc-ai/web-llm";
        window.webllm = webllm;
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: rgba(255, 255, 255, 0.95);
            min-height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.95);
            overflow: hidden;
        }

        .header {
            background: rgba(102, 126, 234, 0.08);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(102, 126, 234, 0.15);
            color: #667eea;
            padding: 25px 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .header p {
            opacity: 0.8;
            font-size: 0.95em;
        }

        .upload-section {
            padding: 20px 30px;
            background: rgba(248, 249, 250, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(102, 126, 234, 0.1);
            transition: all 0.3s ease;
        }

        .upload-section.collapsed {
            padding: 12px 30px;
        }

        .file-input-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .file-input-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .file-input-label {
            display: inline-block;
            padding: 12px 24px;
            background: rgba(102, 126, 234, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: all 0.3s;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        }

        .file-input-label:hover {
            background: rgba(102, 126, 234, 1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
            transform: translateY(-1px);
        }


        input[type="file"] {
            display: none;
        }

        .file-name {
            color: #495057;
            font-size: 0.95em;
            margin-top: 10px;
        }

        .file-display {
            display: none;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }

        .file-display.active {
            display: flex;
        }

        .file-display-name {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #667eea;
            font-weight: 600;
            font-size: 1em;
        }

        .file-display-icon {
            width: 24px;
            height: 24px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
        }

        .change-file-btn {
            padding: 6px 14px;
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.2s;
        }

        .change-file-btn:hover {
            background: rgba(102, 126, 234, 0.2);
            border-color: rgba(102, 126, 234, 0.3);
        }

        .file-input-wrapper.hidden {
            display: none;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background: rgba(248, 249, 250, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-right: 1px solid rgba(102, 126, 234, 0.1);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .content-area {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            height: 100%;
        }

        .submission-list {
            list-style: none;
            flex: 1;
            overflow-y: auto;
        }

        .submission-item {
            padding: 15px 20px;
            border-bottom: 1px solid rgba(102, 126, 234, 0.1);
            cursor: pointer;
            transition: all 0.2s;
        }

        .submission-item:hover {
            background: rgba(102, 126, 234, 0.05);
        }

        .submission-item.active {
            background: rgba(102, 126, 234, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-left: 3px solid #667eea;
            color: #667eea;
        }

        .submission-header {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .submission-score {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .submission-item.active .submission-score {
            opacity: 0.9;
        }

        .stats-bar {
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(102, 126, 234, 0.2);
            font-weight: 600;
            color: #495057;
        }

        .view-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(102, 126, 234, 0.1);
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: rgba(200, 200, 200, 0.15);
            font-size: 1em;
            font-weight: 500;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            margin-bottom: -1px;
            transition: color 0.1s ease-out, background 0.15s ease-out, border-bottom-color 0.1s ease-out;
            border-radius: 6px 6px 0 0;
            position: relative;
        }

        .tab::after {
            content: attr(data-tab);
            font-weight: 600;
            height: 0;
            visibility: hidden;
            overflow: hidden;
            user-select: none;
            pointer-events: none;
            display: block;
        }

        .tab:hover {
            color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.5);
        }

        .tab:active {
            transform: scale(0.98);
            transition: transform 0.05s ease-out;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .code-viewer {
            background: rgba(40, 44, 52, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(102, 126, 234, 0.2);
            overflow: hidden;
            margin-bottom: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        .code-header {
            background: rgba(33, 37, 43, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 10px 15px;
            color: #abb2bf;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(102, 126, 234, 0.2);
        }

        .code-body {
            padding: 0;
            overflow-x: auto;
        }

        pre {
            margin: 0;
            color: #abb2bf;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }

        pre[class*="language-"] {
            margin: 0;
            padding: 20px;
        }

        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }

        /* Line numbers styling */
        .line-numbers .line-numbers-rows {
            border-right: 1px solid #3e4451;
            background: #21252b;
        }

        .line-numbers-rows > span:before {
            color: #5c6370;
        }

        .conversation-viewer {
            background: rgba(248, 249, 250, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(102, 126, 234, 0.1);
        }

        .conv-entry {
            margin-bottom: 25px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            border-left: 3px solid #667eea;
            border: 1px solid rgba(102, 126, 234, 0.1);
            border-left: 3px solid #667eea;
        }

        .conv-entry.user {
            border-left-color: #7b1fa2;
        }

        .conv-entry.output {
            border-left-color: #17a2b8;
        }
        
        .conv-entry.observation {
            border-left-color: #17a2b8; /* Keep for backwards compatibility */
        }

        .conv-entry.action {
            border-left-color: #28a745;
        }

        .conv-entry.assistant {
            border-left-color: #667eea;
        }

        .conv-label {
            font-weight: 600;
            font-size: 0.85em;
            text-transform: uppercase;
            color: #6c757d;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .conv-label:hover {
            color: #495057;
        }

        .conv-toggle {
            font-size: 0.9em;
            color: #6c757d;
            transition: transform 0.2s;
        }

        .conv-entry.collapsed .conv-toggle {
            transform: rotate(-90deg);
        }

        .conv-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
            line-height: 1.6;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            overflow: hidden;
        }

        .conv-entry.collapsed .conv-content {
            max-height: 0 !important;
            opacity: 0;
            margin: 0;
            padding: 0;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .error {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin: 20px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .empty-state h3 {
            margin-bottom: 10px;
            color: #495057;
        }

        .score-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
            background: rgba(232, 245, 233, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(46, 125, 50, 0.2);
            color: #2e7d32;
        }

        .score-badge.best {
            background: rgba(255, 243, 224, 0.8);
            border: 1px solid rgba(230, 81, 0, 0.2);
            color: #e65100;
        }

        .metadata {
            background: rgba(248, 249, 250, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(102, 126, 234, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .metadata-item {
            margin-bottom: 8px;
        }

        .metadata-label {
            font-weight: 600;
            color: #495057;
            display: inline-block;
            width: 150px;
        }

        .workspace-files {
            margin-top: 8px;
            border: 1px solid rgba(102, 126, 234, 0.15);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.65);
            max-height: 260px;
            overflow-y: auto;
        }

        .workspace-file {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            padding: 6px 10px;
            border-bottom: 1px solid rgba(102, 126, 234, 0.08);
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            font-size: 0.82em;
        }

        .workspace-file:last-child {
            border-bottom: none;
        }

        .workspace-file-name {
            color: #334;
            word-break: break-word;
        }

        .workspace-file-lines {
            color: #6c757d;
            white-space: nowrap;
        }

        .summary-section {
            background: rgba(240, 247, 255, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-left: 3px solid #667eea;
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-left: 3px solid #667eea;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .summary-title {
            font-weight: 600;
            color: #495057;
        }

        .generate-summary-btn {
            padding: 6px 12px;
            background: rgba(102, 126, 234, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .generate-summary-btn:hover {
            background: rgba(102, 126, 234, 1);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .generate-summary-btn:disabled {
            background: rgba(204, 204, 204, 0.5);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .copy-code-btn {
            padding: 6px 12px;
            background: rgba(245, 245, 245, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: #333;
            border: 1px solid rgba(221, 221, 221, 0.5);
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            margin-right: 10px;
            transition: all 0.2s ease;
        }

        .copy-code-btn:hover {
            background: rgba(232, 232, 232, 0.9);
            border-color: rgba(204, 204, 204, 0.7);
            transform: translateY(-1px);
        }

        .copy-code-btn:active {
            transform: scale(0.95);
        }

        .copy-code-btn.copied {
            background: rgba(76, 175, 80, 0.9);
            color: white;
            border-color: rgba(76, 175, 80, 0.5);
        }

        .summary-content {
            color: #212529;
            line-height: 1.6;
        }

        .summary-loading {
            color: #6c757d;
            font-style: italic;
        }

        .summary-progress {
            width: 100%;
            height: 4px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
            position: relative;
        }

        .summary-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 2px;
            transition: width 0.3s ease-out;
            position: relative;
        }

        .summary-progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .summary-progress-text {
            font-size: 0.85em;
            color: #6c757d;
            margin-top: 5px;
        }

        /* File tabs for multiple Python files */
        .file-tabs-wrapper {
            position: relative;
            background: rgba(248, 249, 250, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 12px 12px 0 0;
        }

        /* Fade effect on right side to indicate scrollable content */
        .file-tabs-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            bottom: 1px;
            width: 100px;
            background: linear-gradient(to left, rgba(248, 249, 250, 0.5) 0%, rgba(248, 249, 250, 0) 100%);
            pointer-events: none;
            z-index: 5;
        }

        .file-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 0;
            padding: 10px 80px 0 15px; /* Extra right padding for badge */
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            scrollbar-width: thin;
            scrollbar-color: #667eea rgba(248, 249, 250, 0.5);
        }

        /* Webkit scrollbar styling */
        .file-tabs::-webkit-scrollbar {
            height: 6px;
        }

        .file-tabs::-webkit-scrollbar-track {
            background: #f8f9fa;
        }

        .file-tabs::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 3px;
        }

        .file-tabs::-webkit-scrollbar-thumb:hover {
            background: #5568d3;
        }

        .file-tab {
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            background: rgba(200, 200, 200, 0.3);
            font-size: 0.9em;
            font-weight: 500;
            color: #6c757d;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: color 0.1s ease-out, background 0.15s ease-out, border-bottom-color 0.1s ease-out, box-shadow 0.15s ease-out;
            border-radius: 4px 4px 0 0;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .file-tab:hover {
            color: #667eea;
            background: rgba(255, 255, 255, 0.6);
        }

        .file-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: rgba(255, 255, 255, 0.95);
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
        }

        .file-tab:active {
            transform: scale(0.97);
            transition: transform 0.05s ease-out;
        }

        .file-tab-count {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            right: 15px;
            background: #667eea;
            color: white;
            padding: 6px 12px;
            border-radius: 14px;
            font-size: 0.8em;
            font-weight: 600;
            line-height: 1.2;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Trajectory Code Viewer</h1>
            <p>View code submissions and conversations from trajectory files</p>
        </div>

        <div class="upload-section" id="upload-section">
            <div class="file-input-wrapper" id="file-input-wrapper">
                <label for="traj-input" class="file-input-label">
                    Choose .traj File
                </label>
                <input type="file" id="traj-input" accept=".traj" />
                <div class="file-name" id="file-names"></div>
            </div>
            
            <div class="file-display" id="file-display">
                <div class="file-display-name">
                    <div class="file-display-icon">T</div>
                    <span id="current-file-name">No file loaded</span>
                </div>
                <button class="change-file-btn" id="change-file-btn">Change File</button>
            </div>
        </div>

        <div id="main-content" class="main-content" style="display: none;">
            <div class="sidebar">
                <div class="stats-bar" id="stats-bar">
                    <div>Submissions: <span id="total-submissions">0</span></div>
                    <div id="model-status" style="color: #888; font-size: 0.9em; display: none;"></div>
                </div>
                <ul class="submission-list" id="submission-list"></ul>
            </div>

            <div class="content-area">
                <div id="empty-state" class="empty-state">
                    <h3>Select a submission to view</h3>
                    <p>Choose a submission from the sidebar to see the code and conversation</p>
                </div>

                <div id="content-view" style="display: none;">
                    <div class="view-tabs">
                        <button class="tab active" data-tab="code">Code</button>
                        <button class="tab" data-tab="conversation">Conversation</button>
                        <button class="tab" data-tab="metadata">Metadata</button>
                    </div>

                    <div class="tab-content active" id="tab-code">
                        <!-- File tabs for multiple .py files -->
                        <div id="file-tabs-container" style="display: none;"></div>
                        
                        <div class="code-viewer">
                            <div class="code-header">
                                <span id="code-filename">Code File</span>
                                <div>
                                    <button class="copy-code-btn" id="copy-code-btn" title="Copy code to clipboard">Copy Code</button>
                                    <span class="score-badge" id="code-score-badge">Score: -</span>
                                </div>
                            </div>
                            <div class="code-body">
                                <pre class="line-numbers"><code id="code-content" class="language-python">Loading...</code></pre>
                            </div>
                            <div id="no-code-message" style="display: none; padding: 40px; text-align: center; color: #6c757d;">
                                <p>This section contains data preprocessing and exploration steps only.</p>
                                <p>No code was generated yet.</p>
                            </div>
                        </div>
                    </div>

                    <div class="tab-content" id="tab-conversation">
                        <div class="summary-section" id="summary-section" style="display: none;">
                            <div class="summary-header">
                                <div class="summary-title">Approach Summary</div>
                                <button class="generate-summary-btn" id="generate-summary-btn">Generate Summary</button>
                            </div>
                            <div class="summary-content" id="summary-content">Click "Generate Summary" to get an LLM-generated summary of this attempt's approach.</div>
                        </div>
                        <div class="conversation-viewer" id="conversation-content">
                            Loading conversation...
                        </div>
                    </div>

                    <div class="tab-content" id="tab-metadata">
                        <div class="metadata" id="metadata-content">
                            Loading metadata...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let trajectoryData = null;
        let submissions = [];
        let currentSubmissionIndex = -1;
        let engine = null; // WebLLM engine instance
        let isEngineLoading = false;
        let isEngineReady = false;
        const MODEL_NAME = "Llama-3.2-3B-Instruct-q4f32_1-MLC";
        let currentlyGeneratingIndex = -1; // Track which submission is generating a summary
        let isFromAirtableAPI = false; // Track if data came from Airtable API
        let metricLowerIsBetter = false; // Track if lower scores are better (from Airtable)

        const trajInput = document.getElementById('traj-input');
        const fileNames = document.getElementById('file-names');
        const mainContent = document.getElementById('main-content');
        const submissionList = document.getElementById('submission-list');
        const statsBar = document.getElementById('stats-bar');
        const totalSubmissions = document.getElementById('total-submissions');
        const emptyState = document.getElementById('empty-state');
        const contentView = document.getElementById('content-view');
        const uploadSection = document.getElementById('upload-section');
        const fileInputWrapper = document.getElementById('file-input-wrapper');
        const fileDisplay = document.getElementById('file-display');
        const currentFileName = document.getElementById('current-file-name');
        const changeFileBtn = document.getElementById('change-file-btn');

        trajInput.addEventListener('change', handleTrajFile);
        
        changeFileBtn.addEventListener('click', () => {
            // Directly trigger file input dialog
            trajInput.click();
        });

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const targetTab = tab.dataset.tab;
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`tab-${targetTab}`).classList.add('active');
            });
        });

        // Copy code button
        document.getElementById('copy-code-btn').addEventListener('click', async () => {
            const codeElement = document.getElementById('code-content');
            const copyBtn = document.getElementById('copy-code-btn');
            
            try {
                await navigator.clipboard.writeText(codeElement.textContent);
                copyBtn.textContent = 'Copied!';
                copyBtn.classList.add('copied');
                
                setTimeout(() => {
                    copyBtn.textContent = 'Copy Code';
                    copyBtn.classList.remove('copied');
                }, 2000);
            } catch (err) {
                console.error('Failed to copy:', err);
                copyBtn.textContent = 'Failed';
                setTimeout(() => {
                    copyBtn.textContent = 'Copy Code';
                }, 2000);
            }
        });

        function handleTrajFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            // IMPORTANT: Reset all state when loading a new file
            resetViewerState();

            updateFileNames();
            
            // Collapse upload section and show file display
            currentFileName.textContent = file.name;
            fileInputWrapper.classList.add('hidden');
            fileDisplay.classList.add('active');
            uploadSection.classList.add('collapsed');
            
            // Start loading AI model in background as soon as file is uploaded
            if (!engine && !isEngineLoading) {
                console.log('Starting AI model download in background...');
                initializeEngine(); // Don't await - let it load in background
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    trajectoryData = JSON.parse(e.target.result);
                    processTrajectory();
                } catch (error) {
                    alert(`Error parsing trajectory file: ${error.message}`);
                    // Reset UI on error
                    fileInputWrapper.classList.remove('hidden');
                    fileDisplay.classList.remove('active');
                    uploadSection.classList.remove('collapsed');
                }
            };
            reader.readAsText(file);
        }

        function resetViewerState() {
            // Clear data
            trajectoryData = null;
            submissions = [];
            currentSubmissionIndex = -1;
            currentlyGeneratingIndex = -1;
            isFromAirtableAPI = false;
            metricLowerIsBetter = false;
            
            // Reset UI
            submissionList.innerHTML = '';
            totalSubmissions.textContent = '0';
            
            // Hide content view and show empty state
            contentView.style.display = 'none';
            emptyState.style.display = 'block';
            
            // Clear all active selections
            document.querySelectorAll('.submission-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Reset tabs to default (code tab)
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelector('[data-tab="code"]').classList.add('active');
            document.getElementById('tab-code').classList.add('active');
        }

        function updateFileNames() {
            const trajFile = trajInput.files[0]?.name || '';
            if (trajFile) {
                fileNames.textContent = `Selected: ${trajFile}`;
            }
        }

        // Load trajectory file from URL parameter via backend API
        async function loadFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const taskId = urlParams.get('task_id') || urlParams.get('task');
            const trajectory = urlParams.get('trajectory') || '1'; // Default to trajectory 1
            const source = urlParams.get('source') || 'airtable'; // Default to airtable for backwards compatibility

            if (!taskId) return; // No URL parameter, use normal upload flow

            // IMPORTANT: Reset all state when loading from URL
            resetViewerState();

            // Backend API URLs - Cloudflare Workers (always-on, free, fast!)
            const BACKEND_APIS = {
                'airtable': 'https://trajectory-api.andrewgong.workers.dev',
                'studio': 'https://trajectory-studio-api.andrewgong.workers.dev'
            };

            const BACKEND_API = BACKEND_APIS[source] || BACKEND_APIS['airtable'];

            try {
                // Show loading state
                const sourceLabel = source === 'studio' ? 'Studio' : 'Airtable';
                currentFileName.textContent = `Loading Trajectory ${trajectory} from ${sourceLabel}...`;
                fileInputWrapper.classList.add('hidden');
                fileDisplay.classList.add('active');
                uploadSection.classList.add('collapsed');

                // Fetch the file from the backend
                const apiUrl = `${BACKEND_API}/api/trajectory/${taskId}?trajectory=${trajectory}`;
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || `HTTP ${response.status}`);
                }
                
                const text = await response.text();

                // Get dataset name from response header
                const datasetName = response.headers.get('X-Dataset-Name') || taskId;

                // Get metric direction from Airtable API (only for airtable source)
                if (source === 'airtable') {
                    isFromAirtableAPI = true;
                    const metricLowerHeader = response.headers.get('X-Metric-Lower-Is-Better');
                    metricLowerIsBetter = metricLowerHeader === 'true';
                }

                // Update UI with dataset name
                currentFileName.textContent = `${datasetName} (Trajectory ${trajectory})`;
                
                // Start loading AI model in background
                if (!engine && !isEngineLoading) {
                    console.log('Starting AI model download in background...');
                    initializeEngine();
                }
                
                // Process the trajectory
                try {
                    trajectoryData = JSON.parse(text);
                    processTrajectory();
                } catch (error) {
                    alert(`Error parsing trajectory file: ${error.message}`);
                    // Reset UI on error
                    fileInputWrapper.classList.remove('hidden');
                    fileDisplay.classList.remove('active');
                    uploadSection.classList.remove('collapsed');
                }
            } catch (error) {
                alert(`Error loading file: ${error.message}`);
                console.error('URL loading error:', error);
                // Reset UI on error
                fileInputWrapper.classList.remove('hidden');
                fileDisplay.classList.remove('active');
                uploadSection.classList.remove('collapsed');
            }
        }

        function sortCodeFilesByRelevance(codeFiles, command, trajectory, submitStepIdx) {
            // Smart sort to put the most relevant file first
            // Priority: 1) File executed in command, 2) Recently edited files, 3) Non-empty files, 4) Non-utility files
            
            // Extract primary filename from command (e.g., "python train.py" -> "train.py")
            let primaryFile = null;
            if (command) {
                const match = command.match(/python(?:3)?\s+([^\s]+\.py)/);
                if (match) {
                    primaryFile = match[1].trim();
                }
            }
            
            // Count recent edits for each file (look back 50 steps before submit)
            const editCounts = {};
            const startIdx = Math.max(0, submitStepIdx - 50);
            for (let i = startIdx; i < submitStepIdx; i++) {
                const action = trajectory[i]?.action || '';
                const actionTrimmed = action.trim();
                
                // Check for edits or creates
                if (actionTrimmed.startsWith('edit ') || actionTrimmed.startsWith('create ')) {
                    // The file being edited is in the open_file state or can be inferred
                    // For now, we'll use a simpler heuristic: look for file mentions
                    codeFiles.forEach(file => {
                        if (action.includes(file.filename)) {
                            editCounts[file.filename] = (editCounts[file.filename] || 0) + 1;
                        }
                    });
                }
            }
            
            // Utility files to deprioritize
            const utilityFiles = ['evaluate.py', 'current_solution.py', '__init__.py'];
            
            // Sort with multiple criteria
            return codeFiles.sort((a, b) => {
                // 1. Primary file (executed) comes first
                if (a.filename === primaryFile && b.filename !== primaryFile) return -1;
                if (b.filename === primaryFile && a.filename !== primaryFile) return 1;
                
                // 2. Non-utility files before utility files
                const aIsUtility = utilityFiles.includes(a.filename);
                const bIsUtility = utilityFiles.includes(b.filename);
                if (aIsUtility && !bIsUtility) return 1;
                if (bIsUtility && !aIsUtility) return -1;
                
                // 3. Files with more edits first
                const aEdits = editCounts[a.filename] || 0;
                const bEdits = editCounts[b.filename] || 0;
                if (aEdits !== bEdits) return bEdits - aEdits;
                
                // 4. Non-empty files before empty files
                const aEmpty = a.content.trim().length === 0;
                const bEmpty = b.content.trim().length === 0;
                if (aEmpty && !bEmpty) return 1;
                if (bEmpty && !aEmpty) return -1;
                
                // 5. Larger files first (more content = more important)
                if (a.content.length !== b.content.length) {
                    return b.content.length - a.content.length;
                }
                
                // 6. Alphabetical as final tiebreaker
                return a.filename.localeCompare(b.filename);
            });
        }

        function processTrajectory() {
            if (!trajectoryData || !trajectoryData.trajectory) {
                alert('Invalid trajectory file');
                return;
            }

            submissions = extractSubmissions(trajectoryData);
            displaySubmissions();
            mainContent.style.display = 'flex';
        }

        function extractSubmissions(trajJson) {
            const trajectory = trajJson.trajectory;
            const submissions = [];
            
            // Reconstruct files over time
            let files = {};
            let currentFile = null;
            const runEvents = [];
            const submitEvents = [];
            const pendingEdits = []; // Store edits that happen before any file is opened

            function extractCodeBlocks(text) {
                if (!text || typeof text !== 'string') return [];
                const blocks = [];
                const re = /```([\s\S]*?)```/g;
                let match;
                while ((match = re.exec(text)) !== null) {
                    blocks.push(match[1]);
                }
                return blocks;
            }

            function normalizeFilename(raw) {
                if (!raw) return raw;
                return raw.trim().replace(/^["']|["']$/g, '');
            }

            function looksLikeNumberedLines(blockText) {
                if (!blockText || typeof blockText !== 'string') return false;
                const lines = blockText.split('\n').filter(l => l.trim().length > 0);
                if (lines.length < 3) return false;
                const numbered = lines.filter(l => /^\s*\d+[: ]/.test(l)).length;
                return numbered / lines.length >= 0.6;
            }

            function parseNumberedLines(blockText) {
                const mapping = {};
                let maxLine = 0;
                const lines = blockText.split('\n');
                for (const line of lines) {
                    const match = line.match(/^\s*(\d+)[: ](.*)$/);
                    if (match) {
                        const lineNo = parseInt(match[1]);
                        mapping[lineNo] = match[2];
                        if (lineNo > maxLine) maxLine = lineNo;
                    }
                }
                return { mapping, maxLine };
            }

            function stripEndOfEditLines(lines) {
                const body = [];
                for (const line of lines) {
                    if (line.trim() === 'end_of_edit') break;
                    body.push(line);
                }
                return body;
            }

            function parseResponseActions(responseText) {
                const actions = [];
                const blocks = extractCodeBlocks(responseText);
                for (const block of blocks) {
                    const trimmed = block.trim();
                    if (!trimmed) continue;
                    const lines = trimmed.split('\n');
                    const first = lines[0].trim();
                    
                    if (first.startsWith('open ')) {
                        const parts = first.split(/\s+/);
                        if (parts.length >= 2) {
                            actions.push({ type: 'open', filename: normalizeFilename(parts[1]) });
                        }
                        continue;
                    }
                    
                    if (first.startsWith('create ')) {
                        const parts = first.split(/\s+/);
                        if (parts.length >= 2) {
                            const filename = normalizeFilename(parts[1]);
                            const contentLines = stripEndOfEditLines(lines.slice(1));
                            actions.push({ type: 'create', filename, contentLines });
                        }
                        continue;
                    }
                    
                    const editMatch = first.match(/^(?:edit\s+)?(\d+):(\d+)$/);
                    if (editMatch) {
                        const start = parseInt(editMatch[1]);
                        const end = parseInt(editMatch[2]);
                        const contentLines = stripEndOfEditLines(lines.slice(1));
                        actions.push({ type: 'edit', start, end, lines: contentLines });
                        continue;
                    }
                    
                    if (looksLikeNumberedLines(trimmed)) {
                        const parsed = parseNumberedLines(trimmed);
                        actions.push({ type: 'fileview', mapping: parsed.mapping, totalLines: parsed.maxLine });
                    }
                }
                return actions;
            }

            function parseAnyFileObservationMeta(observation) {
                if (!observation || typeof observation !== 'string') return null;
                const lines = observation.split('\n');
                const fileHeaderRe = /^\[File:\s+(.+?)\s+\((\d+)\s+lines total\)\]\s*$/;
                for (let idx = 0; idx < lines.length; idx++) {
                    const match = lines[idx].trim().match(fileHeaderRe);
                    if (match) {
                        const pathStr = match[1].trim();
                        const filename = pathStr.includes('/') ? pathStr.split('/').pop() : pathStr;
                        const totalLines = parseInt(match[2]);
                        const mapping = {};
                        const lineNoRe = /^\s*(\d+):(.*)$/;
                        for (let i = idx + 1; i < lines.length; i++) {
                            const line = lines[i];
                            if (line.trim().startsWith('[File:')) break;
                            const lnMatch = line.match(lineNoRe);
                            if (lnMatch) {
                                const lineNo = parseInt(lnMatch[1]);
                                mapping[lineNo] = lnMatch[2];
                            }
                        }
                        return { filename, totalLines, mapping };
                    }
                }
                return null;
            }

            function applyPendingEditsIfAny() {
                if (!currentFile || pendingEdits.length === 0) return;
                console.log(`Applying ${pendingEdits.length} pending edit(s) to ${currentFile}`);
                for (const pendingEdit of pendingEdits) {
                    const currentLines = files[currentFile] || [];
                    files[currentFile] = applyEdit(currentLines, pendingEdit.start, pendingEdit.end, pendingEdit.lines);
                    
                    if (pendingEdit.meta) {
                        files[currentFile] = overlayAndResize(files[currentFile], pendingEdit.meta.totalLines, pendingEdit.meta.mapping);
                    }
                }
                pendingEdits.length = 0;
            }

            function applyResponseActions(responseActions, step, stepIdx) {
                if (!responseActions || responseActions.length === 0) return;
                for (const ra of responseActions) {
                    if (ra.type === 'open') {
                        currentFile = ra.filename;
                        if (!(currentFile in files)) {
                            files[currentFile] = [];
                        }
                        applyPendingEditsIfAny();
                        continue;
                    }
                    if (ra.type === 'create') {
                        currentFile = ra.filename;
                        if (!(currentFile in files)) {
                            files[currentFile] = [];
                        }
                        if (ra.contentLines && ra.contentLines.length > 0) {
                            files[currentFile] = [...ra.contentLines];
                        }
                        applyPendingEditsIfAny();
                        continue;
                    }
                    if (ra.type === 'edit') {
                        if (!currentFile) {
                            const metaAny = parseAnyFileObservationMeta(step.observation);
                            if (metaAny) {
                                currentFile = metaAny.filename;
                                if (!(currentFile in files)) {
                                    files[currentFile] = [];
                                }
                            }
                        }
                        if (!currentFile) {
                            console.log(`Step ${stepIdx}: Response edit without file context - storing as pending`);
                            pendingEdits.push({
                                start: ra.start,
                                end: ra.end,
                                lines: ra.lines,
                                meta: null,
                                stepIdx: stepIdx
                            });
                            continue;
                        }
                        const currentLines = files[currentFile] || [];
                        files[currentFile] = applyEdit(currentLines, ra.start, ra.end, ra.lines);
                        continue;
                    }
                    if (ra.type === 'fileview') {
                        if (!currentFile) {
                            const metaAny = parseAnyFileObservationMeta(step.observation);
                            if (metaAny) {
                                currentFile = metaAny.filename;
                                if (!(currentFile in files)) {
                                    files[currentFile] = [];
                                }
                            }
                        }
                        if (currentFile) {
                            files[currentFile] = overlayAndResize(files[currentFile], ra.totalLines, ra.mapping);
                        }
                    }
                }
            }

            for (let i = 0; i < trajectory.length; i++) {
                const step = trajectory[i];
                const action = step.action || '';
                const actionTrimmed = action.trim();
                const responseActions = parseResponseActions(step.response || '');
                const actionIsFileOp = actionTrimmed.startsWith('open ') || actionTrimmed.startsWith('create ') || actionTrimmed.startsWith('edit ');
                const actionIsFileView = looksLikeNumberedLines(actionTrimmed);
                const processResponseFirst = responseActions.length > 0 && !(actionIsFileOp || actionIsFileView);

                if (processResponseFirst) {
                    applyResponseActions(responseActions, step, i);
                }

                if (actionTrimmed.startsWith('open ')) {
                    const parts = actionTrimmed.split(/\s+/);
                    if (parts.length >= 2) {
                        currentFile = parts[1].trim().replace(/^["']|["']$/g, '');  // Strip quotes
                        // Use setdefault pattern: initialize if not exists
                        if (!(currentFile in files)) {
                            files[currentFile] = [];
                        }
                        
                        // CRITICAL: Sync file length with observation metadata
                        const meta = parseFileObservationMeta(step.observation, currentFile);
                        if (meta) {
                            files[currentFile] = overlayAndResize(files[currentFile], meta.totalLines, meta.mapping);
                        }
                        
                        // Apply any pending edits to this file
                        applyPendingEditsIfAny();
                    }
                } else if (actionTrimmed.startsWith('create ')) {
                    const parts = actionTrimmed.split(/\s+/);
                    if (parts.length >= 2) {
                        const filename = parts[1].trim().replace(/^["']|["']$/g, '');  // Strip quotes
                        files[filename] = [];
                        currentFile = filename;
                        
                        // CRITICAL: Sync file length with observation metadata
                        const meta = parseFileObservationMeta(step.observation, currentFile);
                        if (meta) {
                            files[currentFile] = overlayAndResize(files[currentFile], meta.totalLines, meta.mapping);
                        }
                        
                        // Apply any pending edits to this newly created file
                        applyPendingEditsIfAny();
                    }
                } else if (actionTrimmed.startsWith('edit ')) {
                    const editResult = parseEditAction(action);
                    if (!editResult) continue; // Invalid edit format, skip
                    
                    // If no file is open, try to infer it from the observation
                    if (!currentFile) {
                        const filenameMatch = step.observation?.match(/\[File:\s*(.+?)\s*\(/);
                        if (filenameMatch) {
                            currentFile = filenameMatch[1].trim();
                            // Extract just the filename, not the full path
                            if (currentFile.includes('/')) {
                                currentFile = currentFile.split('/').pop();
                            }
                            // Initialize if needed
                            if (!(currentFile in files)) {
                                files[currentFile] = [];
                            }
                        } else {
                            // Can't determine file - store as pending edit
                            console.log(`Step ${i}: Edit without file context - storing as pending`);
                            const meta = parseFileObservationMeta(step.observation, null);
                            pendingEdits.push({
                                start: editResult.start,
                                end: editResult.end,
                                lines: editResult.lines,
                                meta: meta,
                                stepIdx: i
                            });
                            continue;  // Skip to next step
                        }
                    }
                    
                    // Apply edit to current file
                    const currentLines = files[currentFile] || [];
                    files[currentFile] = applyEdit(currentLines, editResult.start, editResult.end, editResult.lines);
                    
                    // CRITICAL: Sync file length with observation metadata after edit
                    const meta = parseFileObservationMeta(step.observation, currentFile);
                    if (meta) {
                        files[currentFile] = overlayAndResize(files[currentFile], meta.totalLines, meta.mapping);
                    }
                } else if (actionTrimmed.startsWith('python ') || actionTrimmed.startsWith('python3 ')) {
                    runEvents.push({
                        stepIdx: i,
                        command: actionTrimmed,
                        snapshots: snapshotFiles(files)
                    });
                } else if (actionTrimmed.startsWith('submit')) {
                    const parts = actionTrimmed.split(/\s+/);
                    submitEvents.push({
                        stepIdx: i,
                        submittedPath: parts.length >= 2 ? parts[1].trim() : '',
                        workspaceSnapshot: snapshotFiles(files)
                    });
                } else if (actionIsFileView) {
                    // Some newer trajectories store file views directly in action
                    if (!currentFile) {
                        const metaAny = parseAnyFileObservationMeta(step.observation);
                        if (metaAny) {
                            currentFile = metaAny.filename;
                            if (!(currentFile in files)) {
                                files[currentFile] = [];
                            }
                        }
                    }
                    if (currentFile) {
                        const parsed = parseNumberedLines(actionTrimmed);
                        files[currentFile] = overlayAndResize(files[currentFile], parsed.maxLine, parsed.mapping);
                    }
                }

                if (!processResponseFirst) {
                    applyResponseActions(responseActions, step, i);
                }
            }

            // Warn if there are still pending edits that were never applied
            if (pendingEdits.length > 0) {
                console.warn(`Warning: ${pendingEdits.length} pending edit(s) were never applied (no file was opened after these edits)`);
                console.warn('Pending edit steps:', pendingEdits.map(e => e.stepIdx).join(', '));
            }

            // Extract scores
            let scores = [];
            if (trajJson.info && trajJson.info.score && Array.isArray(trajJson.info.score)) {
                scores = trajJson.info.score.map(s => s.score).filter(s => typeof s === 'number');
            }

            // Determine preprocessing boundary: use first submit event (more reliable than first .py file)
            const firstSubmitIdx = submitEvents.length > 0 ? submitEvents[0].stepIdx : -1;
            const preprocessEndIdx = firstSubmitIdx > 0 ? firstSubmitIdx - 1 : -1;
            const hasNoSubmits = submitEvents.length === 0;

            // Add preprocessing section if there are steps before first submit
            // If there are no submits at all, show the entire trajectory as preprocessing
            const preprocessRangeEnd = hasNoSubmits ? (trajectory.length - 1) : preprocessEndIdx;
            if (preprocessRangeEnd > 0) {
                // Extract python -c and awk fragments from preprocessing steps
                const codeFragments = [];
                for (let i = 0; i <= preprocessRangeEnd; i++) {
                    const step = trajectory[i];
                    const action = step.action || '';
                    const actionTrimmed = action.trim();
                    const observation = step.observation || '';
                    
                    // Extract python -c code
                    if (actionTrimmed.startsWith('python -c')) {
                        let match = actionTrimmed.match(/python\s+-c\s+"(.*)"\s*$/s);
                        if (!match) {
                            match = actionTrimmed.match(/python\s+-c\s+'(.*)'\s*$/s);
                        }
                        if (match) {
                            const code = match[1].replace(/; /g, ';\n');
                            codeFragments.push({
                                step: i,
                                type: 'python',
                                code: code,
                                output: observation.trim()
                            });
                        }
                    }
                    // Extract awk commands
                    else if (actionTrimmed.includes('awk')) {
                        codeFragments.push({
                            step: i,
                            type: 'awk',
                            code: actionTrimmed,
                            output: observation.trim()
                        });
                    }
                }
                
                // Get workspace snapshot for preprocessing phase
                let preprocessSnapshot = {};
                if (hasNoSubmits) {
                    preprocessSnapshot = snapshotFiles(files);
                } else if (submitEvents.length > 0 && submitEvents[0].workspaceSnapshot) {
                    preprocessSnapshot = submitEvents[0].workspaceSnapshot;
                }
                
                // Extract .py files from preprocessing snapshot
                const preprocessPyFiles = Object.entries(preprocessSnapshot)
                    .filter(([filename, _]) => filename.endsWith('.py'))
                    .map(([filename, content]) => ({
                        filename: filename,
                        content: content
                    }));
                
                // Build codeFiles array: .py files first, then inline fragments
                let preprocessCodeFiles = [];
                let combinedCode = '';
                
                // Add .py files
                if (preprocessPyFiles.length > 0) {
                    preprocessCodeFiles = [...preprocessPyFiles];
                    combinedCode = preprocessPyFiles.map(file => {
                        return `# ========== ${file.filename} ==========\n${file.content}`;
                    }).join('\n\n');
                }
                
                // Add inline fragments section
                if (codeFragments.length > 0) {
                    const fragmentsCode = codeFragments.map((frag, idx) => {
                        const lang = frag.type === 'python' ? 'Python' : 'AWK';
                        let fragment = `# Fragment ${idx + 1} (Step ${frag.step}) - ${lang}\n${frag.code}`;
                        
                        // Add output if it exists and is not empty
                        if (frag.output && frag.output.length > 0) {
                            fragment += `\n\n# Output (Step ${frag.step})\n${frag.output}`;
                        }
                        
                        return fragment;
                    }).join('\n\n');
                    
                    // Add fragments as a separate "file" for tabbed view
                    preprocessCodeFiles.push({
                        filename: 'Exploratory Commands',
                        content: fragmentsCode
                    });
                    
                    // Also append to combined view
                    if (combinedCode) {
                        combinedCode += '\n\n# ========== Inline Fragments ==========\n' + fragmentsCode;
                    } else {
                        combinedCode = fragmentsCode;
                    }
                }
                
                // Fallback if nothing found
                if (!combinedCode) {
                    combinedCode = '# No code found in preprocessing phase\n';
                    preprocessCodeFiles = [{filename: 'preprocessing', content: combinedCode}];
                }
                
                const preprocessConversation = buildConversation(trajectory, trajJson.history || [], 0, preprocessRangeEnd);
                const codeType = preprocessPyFiles.length > 0 ? 'multiple-files' : 'preprocessing';
                const commandLabel = preprocessPyFiles.length > 0 ? 
                    `${preprocessPyFiles.length} file${preprocessPyFiles.length > 1 ? 's' : ''} + ${codeFragments.length} fragment${codeFragments.length !== 1 ? 's' : ''}` :
                    `${codeFragments.length} code fragment${codeFragments.length !== 1 ? 's' : ''}`;
                
                submissions.push({
                    attempt: 0, // Special marker for preprocessing
                    stepIdx: preprocessEndIdx,
                    score: null,
                    code: combinedCode,
                    codeType: codeType,
                    codeFiles: preprocessCodeFiles,
                    command: commandLabel,
                    runStepIdx: null,
                    conversation: preprocessConversation,
                    summary: null,
                    isPreprocessing: true,
                    failedSubmission: false,
                    workspaceFiles: buildWorkspaceFileList(preprocessSnapshot)
                });
            }

            // Create submission objects
            const numSubmissions = submitEvents.length;
            const startOffset = preprocessRangeEnd >= 0 ? preprocessRangeEnd : -1;

            // Identify failed submissions by checking observations for errors
            const failedSubmissions = new Set();
            for (let i = 0; i < submitEvents.length; i++) {
                const submitIdx = submitEvents[i].stepIdx;
                const obs = trajectory[submitIdx].observation || '';
                const obsLower = obs.toLowerCase();
                // Enhanced error detection
                if (obsLower.includes('error') || obsLower.includes('failed') || 
                    obsLower.includes('no submission') || obsLower.includes('exception') ||
                    obsLower.includes('invalid') || obs.trim().length === 0) {
                    failedSubmissions.add(i);
                }
            }
            
            // Count successful submissions
            const numSuccessfulSubmits = numSubmissions - failedSubmissions.size;
            
            // Handle score array length mismatch
            // Some trajectory files have an extra baseline score at index 0
            let scoreOffset = 0;
            if (scores.length === numSuccessfulSubmits + 1 && submitEvents.length > 0) {
                // Check if there might be a baseline score before first submission
                const firstSubmitIdx = submitEvents[0].stepIdx;
                // Look for early python runs that might have generated a baseline score
                const earlyRuns = runEvents.filter(r => r.stepIdx < firstSubmitIdx);
                if (earlyRuns.length > 0) {
                    // Skip the first score (likely baseline)
                    scoreOffset = 1;
                    console.warn(`Score array mismatch detected: ${scores.length} scores vs ${numSuccessfulSubmits} successful submits. Using offset ${scoreOffset}.`);
                }
            }
            
            // Map attempts to scores, accounting for failed submissions
            let scoreIndex = 0;
            
            for (let attempt = 0; attempt < numSubmissions; attempt++) {
                const submit = submitEvents[attempt];
                
                // Get score: skip if this submission failed
                const score = failedSubmissions.has(attempt) ? null : 
                              (scoreIndex < scores.length - scoreOffset ? scores[scoreIndex + scoreOffset] : null);
                if (!failedSubmissions.has(attempt)) {
                    scoreIndex++; // Only increment for successful submissions
                }
                
                // Find last run before this submission
                const priorRuns = runEvents.filter(r => r.stepIdx < submit.stepIdx);
                const lastRun = priorRuns[priorRuns.length - 1] || null;

                // Extract code - collect ALL .py files from the last snapshot
                let code = '';
                let codeType = 'unknown';
                let codeFiles = []; // Store separate files for tabbed interface
                
                if (lastRun && lastRun.snapshots) {
                    // Find all .py files in the snapshot
                    const pyFiles = Object.entries(lastRun.snapshots)
                        .filter(([filename, _]) => filename.endsWith('.py'));
                    
                    if (pyFiles.length > 1) {
                        // Multiple files - store as array for tabbed interface
                        codeFiles = pyFiles.map(([filename, content]) => ({
                            filename: filename,
                            content: content
                        }));
                        
                        // Smart sort: put the most relevant file first
                        codeFiles = sortCodeFilesByRelevance(codeFiles, lastRun.command, trajectory, submit.stepIdx);
                        
                        // Also keep concatenated version for backwards compatibility
                        code = codeFiles.map(file => {
                            return `# ========== ${file.filename} ==========\n${file.content}`;
                        }).join('\n\n');
                        codeType = 'multiple-files';
                    } else if (pyFiles.length === 1) {
                        // Single file - just show it
                        code = pyFiles[0][1];
                        codeFiles = [{filename: pyFiles[0][0], content: pyFiles[0][1]}];
                        codeType = 'file';
                    } else {
                        // No .py files, fall back to original logic
                        const codeResult = extractCodeFromCommand(lastRun.command, lastRun.snapshots);
                        code = codeResult.content || '';
                        codeFiles = code ? [{filename: 'code', content: code}] : [];
                        codeType = codeResult.type;
                    }
                }

                // Build conversation - start from AFTER preprocessing for first attempt
                const prevSubmitIdx = attempt > 0 ? submitEvents[attempt - 1].stepIdx : startOffset;
                const endIdx = (attempt === numSubmissions - 1) ? (trajectory.length - 1) : submit.stepIdx;
                const conversation = buildConversation(trajectory, trajJson.history || [], prevSubmitIdx + 1, endIdx);

                const workspaceSnapshot = submit.workspaceSnapshot || (lastRun ? lastRun.snapshots : {});
                const workspaceFiles = buildWorkspaceFileList(workspaceSnapshot);

                submissions.push({
                    attempt: attempt + 1,
                    stepIdx: submit.stepIdx,
                    score: score,
                    code: code,
                    codeType: codeType,
                    codeFiles: codeFiles, // Array of {filename, content} objects
                    command: lastRun ? lastRun.command : '',
                    runStepIdx: lastRun ? lastRun.stepIdx : null,
                    conversation: conversation,
                    summary: null, // Will be populated by LLM API call
                    isPreprocessing: false,
                    failedSubmission: failedSubmissions.has(attempt),
                    workspaceFiles: workspaceFiles
                });
            }

            return submissions;
        }

        function snapshotFiles(files) {
            const snapshots = {};
            for (const [filename, lines] of Object.entries(files)) {
                // Trim leading blank lines (artifacts from line number padding)
                let trimmedLines = [...lines];
                while (trimmedLines.length > 0 && trimmedLines[0].trim() === '') {
                    trimmedLines.shift();
                }
                
                // Trim trailing blank lines
                while (trimmedLines.length > 0 && trimmedLines[trimmedLines.length - 1].trim() === '') {
                    trimmedLines.pop();
                }
                
                snapshots[filename] = trimmedLines.join('\n') + (trimmedLines.length > 0 ? '\n' : '');
            }
            return snapshots;
        }

        function buildWorkspaceFileList(snapshot) {
            if (!snapshot) return [];

            return Object.entries(snapshot)
                .map(([filename, content]) => {
                    const contentStr = typeof content === 'string' ? content : '';
                    const normalized = contentStr.endsWith('\n') ? contentStr.slice(0, -1) : contentStr;
                    const lineCount = normalized.length > 0 ? normalized.split('\n').length : 0;
                    return { filename, lineCount };
                })
                .sort((a, b) => a.filename.localeCompare(b.filename));
        }

        function parseEditAction(action) {
            const lines = action.split('\n');
            const header = lines[0].trim();
            const match = header.match(/^(?:edit\s+)?(\d+):(\d+)$/);
            if (!match) return null;

            const start = parseInt(match[1]);
            const end = parseInt(match[2]);
            const body = [];
            
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === 'end_of_edit') break;
                body.push(lines[i]);
            }

            return { start, end, lines: body };
        }

        function applyEdit(fileLines, start, end, newLines) {
            const result = [...fileLines];
            while (result.length < start - 1) result.push('');
            while (result.length < end) result.push('');
            result.splice(start - 1, end - start + 1, ...newLines);
            return result;
        }

        function parseFileObservationMeta(observation, expectedFilename) {
            // Parse observation for [File: ... (N lines total)]
            if (!observation || typeof observation !== 'string') return null;
            
            const lines = observation.split('\n');
            let headerIdx = null;
            let totalLines = null;
            
            // Find the file header for this specific file
            const fileHeaderRe = /^\[File:\s+(.+?)\s+\((\d+)\s+lines total\)\]\s*$/;
            for (let idx = 0; idx < lines.length; idx++) {
                const match = lines[idx].trim().match(fileHeaderRe);
                if (match) {
                    const pathStr = match[1].trim();
                    if (pathStr.endsWith(expectedFilename)) {
                        headerIdx = idx;
                        totalLines = parseInt(match[2]);
                        break;
                    }
                }
            }
            
            if (headerIdx === null || totalLines === null) return null;
            
            // Extract visible line numbers and content
            const mapping = {};
            const lineNoRe = /^\s*(\d+):(.*)$/;
            for (let i = headerIdx + 1; i < lines.length; i++) {
                const line = lines[i];
                // Stop if another file view begins
                if (line.trim().startsWith('[File:')) break;
                
                const match = line.match(lineNoRe);
                if (match) {
                    const lineNo = parseInt(match[1]);
                    mapping[lineNo] = match[2];
                }
            }
            
            return { totalLines, mapping };
        }

        function overlayAndResize(fileLines, totalLines, mapping) {
            // Resize to exactly totalLines and overlay visible content from mapping
            let result = [...fileLines];
            
            // Resize
            if (result.length > totalLines) {
                result = result.slice(0, totalLines);
            } else if (result.length < totalLines) {
                while (result.length < totalLines) {
                    result.push('');
                }
            }
            
            // Overlay numbered lines we can see in the observation
            for (const [lineNo, text] of Object.entries(mapping)) {
                const idx = parseInt(lineNo) - 1;
                if (idx >= 0 && idx < totalLines) {
                    result[idx] = text;
                }
            }
            
            return result;
        }

        function extractCodeFromCommand(command, snapshots) {
            const cmd = command.trim();
            
            // 1) Handle inline python FIRST (IMPORTANT - matches Python script logic)
            let match = cmd.match(/python(?:3)?\s+-c\s+"(.*)"\s*$/s);
            if (match) {
                const inline = match[1].replace(/; /g, ';\n');
                return { type: 'inline', content: inline + (inline.endsWith('\n') ? '' : '\n') };
            }

            match = cmd.match(/python(?:3)?\s+-c\s+'(.*)'\s*$/s);
            if (match) {
                const inline = match[1].replace(/; /g, ';\n');
                return { type: 'inline', content: inline + (inline.endsWith('\n') ? '' : '\n') };
            }

            // 2) Then handle python script files
            match = cmd.match(/^python(?:3)?\s+([^\s]+)\s*$/);
            if (match) {
                const script = match[1].trim();
                // Try exact match first
                if (snapshots[script]) {
                    return { type: 'file', content: snapshots[script] };
                }
                // Try to find matching file (handle potential whitespace issues)
                for (const [filename, content] of Object.entries(snapshots)) {
                    if (filename.trim() === script) {
                        return { type: 'file', content: content };
                    }
                }
                return { type: 'file', content: null };
            }

            match = cmd.match(/^python(?:3)?\s+([^\s]+)\s+(.+)$/);
            if (match) {
                const script = match[1].trim();
                if (snapshots[script]) {
                    return { type: 'file', content: snapshots[script] };
                }
                for (const [filename, content] of Object.entries(snapshots)) {
                    if (filename.trim() === script) {
                        return { type: 'file', content: content };
                    }
                }
                return { type: 'file', content: null };
            }

            return { type: 'unknown', content: null };
        }

        function extractThoughtFromResponse(response, action) {
            // Extract just the thinking/reasoning part, removing embedded actions
            // Structure is typically: thinking text + </think> + ``` + action + ```
            let thought = response;
            
            if (!thought) return '';
            
            // Look for </think> or </think> marker - everything before it is the thought
            let redactedIndex = thought.indexOf('</think>');
            if (redactedIndex < 0) {
                redactedIndex = thought.indexOf('</think>');
            }
            if (redactedIndex >= 0) {
                thought = thought.substring(0, redactedIndex).trim();
                return thought;
            }
            
            // If no marker, look for code blocks (```) - everything before the first one is the thought
            const codeBlockIndex = thought.indexOf('```');
            if (codeBlockIndex >= 0) {
                thought = thought.substring(0, codeBlockIndex).trim();
                return thought;
            }
            
            // Fallback: if action is in response, try to remove it
            if (action) {
                const actionTrimmed = action.trim();
                const actionIndex = thought.indexOf(actionTrimmed);
                if (actionIndex >= 0) {
                    thought = thought.substring(0, actionIndex).trim();
                }
            }
            
            return thought;
        }

        function buildConversation(trajectory, history, startIdx, endIdx) {
            const entries = [];
            
            for (let i = startIdx; i <= endIdx; i++) {
                const step = trajectory[i];
                
                const obsContent = step.observation ? step.observation.trim() : '';
                
                // Assistant thought/response
                if (step.response) {
                    // Extract just the thought, removing embedded action
                    const thought = extractThoughtFromResponse(step.response, step.action);
                    if (thought.trim()) {
                        entries.push({ type: 'assistant', content: thought, step: i });
                    }
                }
                
                // Action
                if (step.action) {
                    entries.push({ type: 'action', content: step.action, step: i });
                }
                
                // Output (observation)
                if (obsContent) {
                    entries.push({ type: 'output', content: obsContent, step: i });
                }
            }
            return entries;
        }


        function displaySubmissions() {
            // Count only actual attempts (not preprocessing)
            const actualAttempts = submissions.filter(s => !s.isPreprocessing).length;
            totalSubmissions.textContent = actualAttempts;
            submissionList.innerHTML = '';

            // Calculate best score - only show star if data came from Airtable API and scores differ
            const validScores = submissions.filter(s => s.score !== null).map(s => s.score);
            const uniqueScores = [...new Set(validScores)];
            const shouldShowStar = isFromAirtableAPI && uniqueScores.length > 1; // Only show if from Airtable and scores differ

            // Determine best score based on metric direction
            let bestScore;
            if (metricLowerIsBetter) {
                bestScore = validScores.length > 0 ? Math.min(...validScores) : Infinity;
            } else {
                bestScore = validScores.length > 0 ? Math.max(...validScores) : -Infinity;
            }

            submissions.forEach((sub, index) => {
                const li = document.createElement('li');
                li.className = 'submission-item';
                li.dataset.index = index;

                const isBest = shouldShowStar && sub.score !== null && sub.score === bestScore;

                if (sub.isPreprocessing) {
                    li.innerHTML = `
                        <div class="submission-header">Pre-processing</div>
                        <div class="submission-score" style="font-size: 0.85em;">
                            Data exploration
                        </div>
                    `;
                } else {
                    li.innerHTML = `
                        <div class="submission-header">Attempt ${sub.attempt}</div>
                        <div class="submission-score">
                            ${sub.score !== null ? `Score: ${sub.score.toFixed(4)}` : 'Score: N/A'}
                            ${sub.score === null && sub.failedSubmission ? '<span style="margin-left: 6px; color: #c94f4f; font-weight: 500;">(Failed submission score)</span>' : ''}
                            ${isBest ? ' ' : ''}
                        </div>
                    `;
                }

                li.addEventListener('click', () => selectSubmission(index));
                submissionList.appendChild(li);
            });
        }

        function selectSubmission(index) {
            // Don't reset currentlyGeneratingIndex - let generation continue in background
            currentSubmissionIndex = index;
            const sub = submissions[index];

            // Update active state
            document.querySelectorAll('.submission-item').forEach((item, i) => {
                item.classList.toggle('active', i === index);
            });

            // Show content
            emptyState.style.display = 'none';
            contentView.style.display = 'block';

            // Handle preprocessing section differently
            const codeTab = document.querySelector('[data-tab="code"]');
            const codeViewer = document.querySelector('.code-viewer');
            const noCodeMessage = document.getElementById('no-code-message');
            const summarySection = document.getElementById('summary-section');
            
            if (sub.isPreprocessing) {
                // Show code tab for preprocessing
                codeTab.style.display = 'block';
                codeViewer.style.display = 'block';
                noCodeMessage.style.display = 'none';
                
                // Handle multiple files with tabs (same as regular attempts)
                const fileTabsContainer = document.getElementById('file-tabs-container');
                
                if (sub.codeFiles && sub.codeFiles.length > 1) {
                    // Multiple files - show file tabs
                    fileTabsContainer.style.display = 'block';
                    fileTabsContainer.innerHTML = '<div class="file-tabs-wrapper">' +
                        '<div class="file-tabs">' +
                        sub.codeFiles.map((file, idx) => 
                            `<button class="file-tab ${idx === 0 ? 'active' : ''}" data-file-index="${idx}">${file.filename}</button>`
                        ).join('') +
                        '</div>' +
                        `<span class="file-tab-count">${sub.codeFiles.length} file${sub.codeFiles.length > 1 ? 's' : ''}</span>` +
                        '</div>';
                    
                    // Add click handlers for file tabs
                    fileTabsContainer.querySelectorAll('.file-tab').forEach(tab => {
                        tab.addEventListener('click', () => {
                            const fileIndex = parseInt(tab.dataset.fileIndex);
                            showCodeFile(sub, fileIndex);
                            // Update active tab
                            fileTabsContainer.querySelectorAll('.file-tab').forEach(t => t.classList.remove('active'));
                            tab.classList.add('active');
                        });
                    });
                    
                    // Show first file by default
                    showCodeFile(sub, 0);
                } else {
                    // Single file - hide tabs
                    fileTabsContainer.style.display = 'none';
                    
                    // Update code view for single file/fragments
                    const filename = sub.codeFiles && sub.codeFiles.length === 1 ? sub.codeFiles[0].filename : 'Preprocessing';
                    document.getElementById('code-filename').textContent = filename;
                    document.getElementById('code-score-badge').textContent = sub.command || 'Preprocessing';
                    
                    const codeText = sub.code || '# No code found';
                    displayCodeContent(codeText);
                }
                
                // Show summary section for preprocessing too
                const summaryContent = document.getElementById('summary-content');
                const generateBtn = document.getElementById('generate-summary-btn');
                
                summarySection.style.display = 'block';
                if (currentlyGeneratingIndex === index) {
                    // This attempt is currently generating in the background
                    summaryContent.innerHTML = `
                        <div class="summary-loading">Generating summary...</div>
                        <div class="summary-progress">
                            <div class="summary-progress-bar" id="summary-progress-bar" style="width: 50%"></div>
                        </div>
                        <div class="summary-progress-text" id="summary-progress-text">In progress...</div>
                    `;
                    generateBtn.disabled = true;
                } else if (currentlyGeneratingIndex !== -1) {
                    // Another attempt is currently generating
                    const generatingAttempt = submissions[currentlyGeneratingIndex];
                    const attemptLabel = generatingAttempt.isPreprocessing ? 'Pre-processing' : `Attempt ${generatingAttempt.attempt}`;
                    summaryContent.innerHTML = `<div style="color: #6c757d; font-style: italic;">Summary generation is in progress for ${attemptLabel}. Please wait for it to complete before generating another summary.</div>`;
                    summaryContent.classList.remove('summary-loading');
                    generateBtn.disabled = true;
                } else if (sub.summary) {
                    summaryContent.innerHTML = renderMarkdown(sub.summary);
                    summaryContent.classList.remove('summary-loading');
                    generateBtn.disabled = false;
                } else {
                    summaryContent.textContent = 'Click "Generate Summary" to get an LLM-generated summary of this phase.';
                    summaryContent.classList.remove('summary-loading');
                    generateBtn.disabled = false;
                }
                
                // Update button click handler
                generateBtn.onclick = () => generateSummary(index);
                
                // Default to conversation tab for preprocessing since that's often more interesting
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
                document.querySelector('[data-tab="conversation"]').classList.add('active');
                document.getElementById('tab-conversation').classList.add('active');
            } else {
                // Show code tab for regular attempts
                codeTab.style.display = 'block';
                codeViewer.style.display = 'block';
                noCodeMessage.style.display = 'none';
                
                // Update summary section
                const summaryContent = document.getElementById('summary-content');
                const generateBtn = document.getElementById('generate-summary-btn');
                
                summarySection.style.display = 'block';
                if (currentlyGeneratingIndex === index) {
                    // This attempt is currently generating in the background
                    summaryContent.innerHTML = `
                        <div class="summary-loading">Generating summary...</div>
                        <div class="summary-progress">
                            <div class="summary-progress-bar" id="summary-progress-bar" style="width: 50%"></div>
                        </div>
                        <div class="summary-progress-text" id="summary-progress-text">In progress...</div>
                    `;
                    generateBtn.disabled = true;
                } else if (currentlyGeneratingIndex !== -1) {
                    // Another attempt is currently generating
                    const generatingAttempt = submissions[currentlyGeneratingIndex];
                    const attemptLabel = generatingAttempt.isPreprocessing ? 'Pre-processing' : `Attempt ${generatingAttempt.attempt}`;
                    summaryContent.innerHTML = `<div style="color: #6c757d; font-style: italic;">Summary generation is in progress for ${attemptLabel}. Please wait for it to complete before generating another summary.</div>`;
                    summaryContent.classList.remove('summary-loading');
                    generateBtn.disabled = true;
                } else if (sub.summary) {
                    summaryContent.innerHTML = renderMarkdown(sub.summary);
                    summaryContent.classList.remove('summary-loading');
                    generateBtn.disabled = false;
                } else {
                    summaryContent.textContent = 'Click "Generate Summary" to get an LLM-generated summary of this attempt\'s approach.';
                    summaryContent.classList.remove('summary-loading');
                    generateBtn.disabled = false;
                }
                
                // Update button click handler
                generateBtn.onclick = () => generateSummary(index);

                // Handle multiple files with tabs
                const fileTabsContainer = document.getElementById('file-tabs-container');
                
                if (sub.codeFiles && sub.codeFiles.length > 1) {
                    // Multiple files - show file tabs
                    fileTabsContainer.style.display = 'block';
                    fileTabsContainer.innerHTML = '<div class="file-tabs-wrapper">' +
                        '<div class="file-tabs">' +
                        sub.codeFiles.map((file, idx) => 
                            `<button class="file-tab ${idx === 0 ? 'active' : ''}" data-file-index="${idx}">${file.filename}</button>`
                        ).join('') +
                        '</div>' +
                        `<span class="file-tab-count">${sub.codeFiles.length} file${sub.codeFiles.length > 1 ? 's' : ''}</span>` +
                        '</div>';
                    
                    // Add click handlers for file tabs
                    fileTabsContainer.querySelectorAll('.file-tab').forEach(tab => {
                        tab.addEventListener('click', () => {
                            const fileIndex = parseInt(tab.dataset.fileIndex);
                            showCodeFile(sub, fileIndex);
                            // Update active tab
                            fileTabsContainer.querySelectorAll('.file-tab').forEach(t => t.classList.remove('active'));
                            tab.classList.add('active');
                        });
                    });
                    
                    // Show first file by default
                    showCodeFile(sub, 0);
                } else {
                    // Single file or no files - hide tabs
                    fileTabsContainer.style.display = 'none';
                    
                    // Update code view for single file
                    const filename = sub.codeFiles && sub.codeFiles.length === 1 ? sub.codeFiles[0].filename : 
                                     sub.codeType === 'file' ? 'Python File' : 
                                     sub.codeType === 'inline' ? 'Inline Python Code' : 'Unknown';
                    document.getElementById('code-filename').textContent = filename;
                    document.getElementById('code-score-badge').textContent = 
                        sub.score !== null ? `Score: ${sub.score.toFixed(4)}` : 'Score: N/A';
                    
                    const codeText = sub.code || '# No code available for this submission';
                    displayCodeContent(codeText);
                }
            }

            // Update conversation view
            const convContent = document.getElementById('conversation-content');
            convContent.innerHTML = '';
            if (sub.conversation.length === 0) {
                convContent.innerHTML = '<div class="empty-state"><p>No conversation available</p></div>';
            } else {
                sub.conversation.forEach(entry => {
                    const div = document.createElement('div');
                    div.className = `conv-entry ${entry.type}`;
                    
                    // Determine if should be collapsed by default (long content)
                    const shouldCollapse = entry.content.length > 500 && entry.type === 'output';
                    if (shouldCollapse) {
                        div.classList.add('collapsed');
                    }
                    
                    div.innerHTML = `
                        <div class="conv-label">
                            <span>[Step ${entry.step}] ${entry.type.toUpperCase()}</span>
                            <span class="conv-toggle"></span>
                        </div>
                        <div class="conv-content">${escapeHtml(entry.content)}</div>
                    `;
                    
                    // Add click handler to toggle collapse
                    const label = div.querySelector('.conv-label');
                    label.addEventListener('click', () => {
                        div.classList.toggle('collapsed');
                    });
                    
                    convContent.appendChild(div);
                });
            }

            // Update metadata
            const metaContent = document.getElementById('metadata-content');
            const workspaceFiles = sub.workspaceFiles || [];
            const workspaceFilesHtml = workspaceFiles.length > 0
                ? `<div class="workspace-files">${workspaceFiles.map(file => `
                    <div class="workspace-file">
                        <span class="workspace-file-name">${escapeHtml(file.filename)}</span>
                        <span class="workspace-file-lines">${file.lineCount} line${file.lineCount === 1 ? '' : 's'}</span>
                    </div>
                `).join('')}</div>`
                : '<div class="workspace-files"><div class="workspace-file"><span class="workspace-file-name">No files captured</span><span class="workspace-file-lines">0 lines</span></div></div>';

            metaContent.innerHTML = `
                <div class="metadata-item">
                    <span class="metadata-label">Attempt:</span>
                    <span>${sub.attempt}</span>
                </div>
                <div class="metadata-item">
                    <span class="metadata-label">Submit Step:</span>
                    <span>${sub.stepIdx}</span>
                </div>
                <div class="metadata-item">
                    <span class="metadata-label">Run Step:</span>
                    <span>${sub.runStepIdx !== null ? sub.runStepIdx : 'N/A'}</span>
                </div>
                <div class="metadata-item">
                    <span class="metadata-label">Score:</span>
                    <span>${sub.score !== null ? sub.score.toFixed(4) : (sub.failedSubmission ? 'N/A (Failed submission score)' : 'N/A')}</span>
                </div>
                <div class="metadata-item">
                    <span class="metadata-label">Command:</span>
                    <span>${escapeHtml(sub.command || 'N/A')}</span>
                </div>
                <div class="metadata-item">
                    <span class="metadata-label">Code Type:</span>
                    <span>${sub.codeType}</span>
                </div>
                <div class="metadata-item">
                    <span class="metadata-label">Workspace Files:</span>
                    <span>${workspaceFiles.length}</span>
                </div>
                ${workspaceFilesHtml}
            `;
        }

        function showCodeFile(sub, fileIndex) {
            // Display a specific file from the codeFiles array
            const file = sub.codeFiles[fileIndex];
            document.getElementById('code-filename').textContent = file.filename;
            
            // For preprocessing, show the command label instead of score
            if (sub.isPreprocessing) {
                document.getElementById('code-score-badge').textContent = sub.command || 'Preprocessing';
            } else {
                document.getElementById('code-score-badge').textContent = 
                    sub.score !== null ? `Score: ${sub.score.toFixed(4)}` : 'Score: N/A';
            }
            
            displayCodeContent(file.content);
        }

        function displayCodeContent(codeText) {
            // Display code with syntax highlighting
            const codeElement = document.getElementById('code-content');
            codeElement.textContent = codeText;
            codeElement.className = 'language-python';
            
            // Highlight syntax using Prism with line numbers
            if (window.Prism && codeText && codeText !== '# No code available for this submission') {
                // Clear previous content
                const preElement = codeElement.parentElement;
                preElement.innerHTML = '';
                const newCode = document.createElement('code');
                newCode.id = 'code-content';
                newCode.className = 'language-python';
                newCode.textContent = codeText;
                preElement.appendChild(newCode);
                
                // Apply syntax highlighting
                Prism.highlightElement(newCode);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /*
         * WebLLM INITIALIZATION
         * 
         * Initialize the WebLLM engine with a model.
         * This runs the LLM directly in the browser using WebGPU.
         * No API keys or backend needed!
         */
        function renderMarkdown(text) {
            // Simple markdown renderer for LLM output
            // Handles: **bold**, *italic*, `code`, and line breaks
            return text
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')  // **bold**
                .replace(/\*(.+?)\*/g, '<em>$1</em>')               // *italic*
                .replace(/`(.+?)`/g, '<code>$1</code>')             // `code`
                .replace(/\n/g, '<br>');                             // line breaks
        }

        async function initializeEngine() {
            if (engine || isEngineLoading) return;
            
            isEngineLoading = true;
            isEngineReady = false;
            const modelStatus = document.getElementById('model-status');
            
            try {
                // Show status in stats bar
                if (modelStatus) {
                    modelStatus.style.display = 'block';
                    modelStatus.textContent = 'AI model loading...';
                }
                
                // Wait for WebLLM to load
                let attempts = 0;
                while (!window.webllm && attempts < 50) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                if (!window.webllm) {
                    throw new Error('WebLLM library failed to load. Please refresh the page and try again.');
                }
                
                // Create engine with progress callback
                engine = await window.webllm.CreateMLCEngine(
                    MODEL_NAME, // Smaller, faster model
                    {
                        initProgressCallback: (progress) => {
                            if (modelStatus) {
                                if (progress.progress) {
                                    modelStatus.textContent = `AI model: ${(progress.progress * 100).toFixed(0)}%`;
                                } else if (progress.text) {
                                    modelStatus.textContent = `AI: ${progress.text}`;
                                }
                            }
                        }
                    }
                );
                
                if (modelStatus) {
                    modelStatus.textContent = ' AI model ready';
                    modelStatus.style.color = '#4CAF50';
                }
                isEngineReady = true;
                isEngineLoading = false;
                
            } catch (error) {
                console.error('Error initializing WebLLM:', error);
                if (modelStatus) {
                    modelStatus.textContent = ` AI model failed to load`;
                    modelStatus.style.color = '#f44336';
                }
                isEngineLoading = false;
                engine = null;
                isEngineReady = false;
            }
        }

        async function ensureEngineReady() {
            if (!engine && !isEngineLoading) {
                await initializeEngine();
            }

            if (isEngineLoading) {
                while (isEngineLoading) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }

            if (!engine) return false;
            if (isEngineReady) return true;

            // Fallback: try reloading the model if engine exists but isn't ready
            if (engine?.reload) {
                try {
                    await engine.reload(MODEL_NAME);
                    isEngineReady = true;
                    return true;
                } catch (error) {
                    console.error('Error reloading WebLLM model:', error);
                }
            }

            return false;
        }

        /*
         * LLM SUMMARIZATION using WebLLM
         * 
         * This runs a local LLM directly in the browser using WebGPU.
         * No API keys or backend needed!
         * 
         * Models available: https://github.com/mlc-ai/web-llm#available-models
         * 
         * Recommended models (change in initializeEngine function):
         * - Llama-3.1-8B-Instruct-q4f16_1-MLC (default, ~5GB, best quality)
         * - Qwen2.5-7B-Instruct-q4f16_1-MLC (~4GB, excellent quality)
         * - Llama-3.2-3B-Instruct-q4f32_1-MLC (~2GB, faster but lower quality)
         * - Phi-3.5-mini-instruct-q4f16_1-MLC (~2GB, good balance)
         */
        async function generateSummary(submissionIndex) {
            const sub = submissions[submissionIndex];
            const summaryContent = document.getElementById('summary-content');
            const generateBtn = document.getElementById('generate-summary-btn');
            
            // Check if another summary is already being generated
            if (currentlyGeneratingIndex !== -1) {
                return; // Don't start a new generation
            }
            
            // Mark this submission as currently generating
            currentlyGeneratingIndex = submissionIndex;
            
            // Initialize engine if not already done
            if (!engine || !isEngineReady || isEngineLoading) {
                if (currentlyGeneratingIndex === submissionIndex) {
                    summaryContent.textContent = 'Initializing AI model (first time)...';
                    summaryContent.classList.add('summary-loading');
                }
                const ready = await ensureEngineReady();
                if (!ready) {
                    if (currentlyGeneratingIndex === submissionIndex) {
                        summaryContent.textContent = 'AI model failed to load. Please refresh and try again.';
                        summaryContent.classList.remove('summary-loading');
                    }
                    currentlyGeneratingIndex = -1;
                    return; // Initialization failed
                }
            }
            
            // Check if user switched away before we start
            if (currentlyGeneratingIndex !== submissionIndex) {
                return;
            }
            
            // Show loading state with progress bar
            generateBtn.disabled = true;
            summaryContent.innerHTML = `
                <div class="summary-loading">Generating summary...</div>
                <div class="summary-progress">
                    <div class="summary-progress-bar" id="summary-progress-bar" style="width: 0%"></div>
                </div>
                <div class="summary-progress-text" id="summary-progress-text">Preparing...</div>
            `;
            
            try {
                // Build the prompt from conversation and code (truncate if too long)
                const conversationText = sub.conversation
                    .slice(0, 10) // Only use first 10 conversation entries to keep context reasonable
                    .map(entry => `${entry.type.toUpperCase()}: ${entry.content.slice(0, 500)}`)
                    .join('\n\n');
                
                const codeSnippet = sub.code ? sub.code.slice(0, 2000) : 'No code available';
                
                // Get previous attempt code if it exists (skip preprocessing)
                let prevCodeSnippet = '';
                if (submissionIndex > 0) {
                    let prevIndex = submissionIndex - 1;
                    let prevSub = submissions[prevIndex];
                    
                    // Skip backwards to find the last non-preprocessing submission
                    while (prevSub && prevSub.isPreprocessing && prevIndex > 0) {
                        prevIndex--;
                        prevSub = submissions[prevIndex];
                    }
                    
                    if (prevSub && !prevSub.isPreprocessing) {
                        prevCodeSnippet = prevSub.code ? prevSub.code.slice(0, 2000) : '';
                    }
                }
                
                // Single unified prompt structure
                const prompt = `Read this AI model's attempt at an ML competition and provide a concise summary of what it is doing in this attempt. This attempt is one of several attempts within a long trajectory. It may be missing a previous attempt or current attempt code if it is the first or second attempt, in which case you should use the conversation to understand its data exploration and pre-processing steps.

Previous Attempt Code:
${prevCodeSnippet}

Current Attempt Code:
${codeSnippet}

Conversation:
${conversationText}

In your summary, write 3-5 sentences that capture the key steps taken by the model and the high-level approach. Be specific about approaches, libraries, and techniques used to help someone understand how this approach may differ from other approaches. Do not include any other text to preface or conclude the summary.`;

                // Generate summary using WebLLM with streaming
                const messages = [
                    {
                        role: "system",
                        content: "You are a helpful AI assistant that summarizes machine learning code and experiments concisely."
                    },
                    {
                        role: "user",
                        content: prompt
                    }
                ];
                
                const progressBar = document.getElementById('summary-progress-bar');
                const progressText = document.getElementById('summary-progress-text');
                
                // Update progress to show we're processing
                if (progressText) progressText.textContent = 'Processing prompt...';
                if (progressBar) progressBar.style.width = '5%';
                
                // Yield to browser to allow UI updates before heavy computation
                await new Promise(resolve => setTimeout(resolve, 0));
                
                // Allow one more frame for rendering
                await new Promise(resolve => requestAnimationFrame(() => resolve()));
                
                // Use streaming for real-time progress
                // Note: This call does heavy prompt processing via WebGPU
                const asyncChunkGenerator = await engine.chat.completions.create({
                    messages: messages,
                    temperature: 0.7,
                    max_tokens: 300,
                    stream: true,
                });
                
                // Update UI to show generation started
                if (progressText) progressText.textContent = 'Starting generation...';
                if (progressBar) progressBar.style.width = '10%';
                
                let summary = '';
                let tokenCount = 0;
                const maxTokens = 300;
                let lastUpdateTime = Date.now();
                let lastUpdateCount = 0;
                let lastYieldTime = Date.now();
                const updateThrottleMs = 100; // Update UI at most every 100ms
                const updateThrottleTokens = 5; // Or every 5 tokens
                const yieldThrottleMs = 200; // Yield to browser every 200ms
                
                for await (const chunk of asyncChunkGenerator) {
                    const delta = chunk.choices[0]?.delta?.content || '';
                    if (delta) {
                        summary += delta;
                        tokenCount++;
                        
                        // Throttle progress bar updates to reduce DOM manipulation
                        const now = Date.now();
                        const timeSinceUpdate = now - lastUpdateTime;
                        const tokensSinceUpdate = tokenCount - lastUpdateCount;
                        
                        // Update only if enough time has passed OR enough tokens generated
                        if (currentSubmissionIndex === submissionIndex && 
                            (timeSinceUpdate >= updateThrottleMs || tokensSinceUpdate >= updateThrottleTokens)) {
                            const progress = Math.min((tokenCount / maxTokens) * 100, 95);
                            if (progressBar) progressBar.style.width = `${progress}%`;
                            if (progressText) progressText.textContent = `Generating... ${tokenCount} tokens`;
                            lastUpdateTime = now;
                            lastUpdateCount = tokenCount;
                        }
                        
                        // Periodically yield to browser to keep UI responsive
                        const timeSinceYield = now - lastYieldTime;
                        if (timeSinceYield >= yieldThrottleMs) {
                            await new Promise(resolve => setTimeout(resolve, 0));
                            lastYieldTime = Date.now();
                        }
                    }
                }
                
                // Store the summary (always, regardless of current view)
                sub.summary = summary.trim();
                
                // Only update UI if we're still viewing this attempt
                if (currentSubmissionIndex === submissionIndex) {
                    // Force a final update to show actual token count
                    const finalProgressBar = document.getElementById('summary-progress-bar');
                    const finalProgressText = document.getElementById('summary-progress-text');
                    if (finalProgressBar) finalProgressBar.style.width = '95%';
                    if (finalProgressText) finalProgressText.textContent = `Generating... ${tokenCount} tokens`;
                    
                    // Brief pause before completion animation
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Complete progress
                    const currentProgressBar = document.getElementById('summary-progress-bar');
                    const currentProgressText = document.getElementById('summary-progress-text');
                    if (currentProgressBar) currentProgressBar.style.width = '100%';
                    if (currentProgressText) currentProgressText.textContent = 'Complete!';
                    
                    // Small delay to show completion
                    await new Promise(resolve => setTimeout(resolve, 300));
                    
                    // Display the summary with markdown rendering
                    const currentSummaryContent = document.getElementById('summary-content');
                    if (currentSummaryContent) {
                        currentSummaryContent.innerHTML = renderMarkdown(sub.summary);
                        currentSummaryContent.classList.remove('summary-loading');
                    }
                }
                
            } catch (error) {
                console.error('Error generating summary:', error);
                // Only show error if we're still viewing this attempt
                if (currentSubmissionIndex === submissionIndex) {
                    const currentSummaryContent = document.getElementById('summary-content');
                    if (currentSummaryContent) {
                        currentSummaryContent.textContent = `Error generating summary: ${error.message}. Please try again.`;
                        currentSummaryContent.classList.remove('summary-loading');
                    }
                }
            } finally {
                // Always clear generation state when done
                currentlyGeneratingIndex = -1;
                
                // Re-enable button if we're currently viewing this attempt
                if (currentSubmissionIndex === submissionIndex) {
                    const currentBtn = document.getElementById('generate-summary-btn');
                    if (currentBtn) {
                        currentBtn.disabled = false;
                    }
                }
            }
        }

        // Check for URL parameter on page load
        window.addEventListener('DOMContentLoaded', () => {
            loadFromURL();
        });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>
